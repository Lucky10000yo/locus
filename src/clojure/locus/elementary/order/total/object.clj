(ns locus.elementary.order.total.object
  (:require [locus.base.logic.core.set :refer :all]
            [locus.base.logic.limit.product :refer :all]
            [locus.base.function.core.object :refer :all]
            [locus.base.logic.structure.protocols :refer :all]
            [locus.elementary.copresheaf.core.protocols :refer :all]
            [locus.elementary.relation.binary.br :refer :all]
            [locus.elementary.relation.binary.sr :refer :all]
            [locus.elementary.relation.binary.product :refer :all]
            [locus.elementary.quiver.core.object :refer :all]
            [locus.elementary.quiver.unital.object :refer :all]
            [locus.elementary.lattice.core.object :refer :all])
  (:import (locus.elementary.quiver.core.object Quiver)))

; Let X be a thin category, then X is a total order provided that for each
; x,y in X we have that either x <= y or y <= x. The key role of total orders
; in topos theory and topology is that we can get an order topology from any
; total order generated by the open rays of the total order. This allows us to
; reason about total orders topologically. Every total order is then associated to
; a Grothendieck topos of sheaves on the site of its order topology.

(deftype TotallyOrderedSet [coll rel]
  ConcreteObject
  (underlying-set [this] coll)

  StructuredLattice
  (join-fn [this]
    (monoidalize
      (fn [a b]
        (if (rel (list a b))
          b
          a))))
  (meet-fn [this]
    (monoidalize
      (fn [a b]
        (if (rel (list a b))
          a
          b))))

  ; Structured quivers
  StructuredDiset
  (first-set [this] rel)
  (second-set [this] coll)

  StructuredQuiver
  (underlying-quiver [this] (->Quiver (first-set this) (second-set this) first second))
  (source-fn [this] first)
  (target-fn [this] second)
  (transition [this e] e)

  StructuredUnitalQuiver
  (underlying-unital-quiver [this]
    (->UnitalQuiver (first-set this) (second-set this) first second (fn [i] (list i i))))
  (identity-morphism-of [this x]
    (list x x))

  ; Every thin category is a function
  ConcreteMorphism
  (inputs [this] (composability-relation this))
  (outputs [this] rel)

  clojure.lang.IFn
  (invoke [this [[a b] [c d]]] (list c b))
  (applyTo [this args] (clojure.lang.AFn/applyToHelper this args)))

(derive TotallyOrderedSet :locus.elementary.copresheaf.core.protocols/lattice)

; Underlying relations
(defmethod underlying-relation TotallyOrderedSet
  [^TotallyOrderedSet this]

  (.rel this))

(defmethod visualize TotallyOrderedSet
  [this]

  (visualize (covering-relation (underlying-relation this))))

; Conversion routines
(defmulti to-totally-ordered-set type)

(defmethod to-totally-ordered-set TotallyOrderedSet
  [toset] toset)

(defmethod to-totally-ordered-set Quiver
  [quiv]

  (TotallyOrderedSet.
    (objects quiv)
    (underlying-relation quiv)))

; Relational total orders
(defn relational-totally-ordered-set
  [rel]

  (TotallyOrderedSet.
    (vertices rel)
    rel))

(defmethod to-totally-ordered-set :default
  [rel]

  (relational-totally-ordered-set rel))

; Totally ordered sets have duals
(defmethod dual TotallyOrderedSet
  [coll]

  (TotallyOrderedSet. (underlying-set coll) (transpose (underlying-relation coll))))

; Restrict a totally ordered set to a subset
(defn restrict-total-order
  [order coll]

  (TotallyOrderedSet.
    coll
    (subrelation (underlying-relation order) coll)))

; Create a finite total order from a distinct vector
(defn finite-total-order
  [coll]

  (TotallyOrderedSet.
    (set coll)
    (->SeqableRelation
      (set coll)
      (fn [[a b]]
       (<= (.indexOf coll a) (.indexOf coll b)))
      {})))

(defn as-toset
  [coll]

  (TotallyOrderedSet.
    coll
    (fn [[a b]]
      (and
        (coll a)
        (coll b)
        (<= a b)))))

; Get the order theoretic concatenation of total orders
(defn concatenate-total-orders
  [& orders]

  (TotallyOrderedSet.
    (apply cartesian-coproduct-classifier (map underlying-set orders))
    (->Universal
      (fn [[[i v] [j w]]]
       (or
         (< i j)
         (and
           (= i j)
           ((morphisms (nth orders i)) (list v w))))))))

; A finite sequence size suborder of a total order can only have
; finitely many limit points with respect to its order topology.
(defn finite-sequence-size-total-order
  [& nums]

  (apply
    concatenate-total-orders
    (map
      (fn [i]
        (case i
          0 (finite-total-order 0)
          1 (as-toset positive-integer?)
          -1 (as-toset negative-integer?)))
      nums)))

; The main way that we produce total orders with infinite sequence sizes
; is by using the lexicographic product, which naturally allows us to
; define scattered total order types that are at most order polynomials
(defn lexicographic-product-total-order
  [a b]

  (let [arel (underlying-relation a)
        brel (underlying-relation b)]
    (TotallyOrderedSet.
     (cartesian-product-classifier (underlying-set a) (underlying-set b))
     (fn [[[a1 b1] [a2 b2]]]
       (or
         (arel (list a1 a2))
         (and
           (= a1 a2)
           (brel (list b1 b2))))))))
